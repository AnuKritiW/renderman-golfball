// dimples.osl
/*
    Pattern Shader: Dimple Displacement + Dirt Masking
    ---------------------------------------------------
    This shader:
    1. Computes a displacement amount (`dispAmount`) for each point based on proximity to dimple centers.
    2. Outputs a `shadowTint` color that includes:
       - a shadowing effect inside dimples
       - procedural dirt around dimple rims using noise
*/

#include "dimple_centers.oslinclude"

shader dimples(
    float dimple_radius = 0.105,
    float dimple_depth = 0.2,
    int numDimples = 377,
    output float dispAmount = 0.0,
    output color shadowTint = color(1.0))
{
    // Normalize position to unit sphere (in object space)
    vector pos = normalize(transform("object", P));

    // Track the closest dimple within the radius
    float minAngle = dimple_radius;
    float bestFalloff = 0.0;

    for (int i = 0; i < numDimples; ++i)
    {
        point center = get_dimple_center(i);
        float angle = acos(dot(pos, normalize(vector(center))));

        if (angle < minAngle)
        {
            minAngle = angle;
            // float t = clamp(angle / dimple_radius, 0.0, 1.0);
            // float falloff = pow(1.0 - t, 4); // Exponential falloff for sharper edges
            float falloff = 1.0 - smoothstep(0.0, dimple_radius, angle);
            bestFalloff = falloff;
        }
    }

    // Apply dimple depth displacement
    dispAmount -= bestFalloff * dimple_depth;

    // Shadow effect: darken color by 0.3Ã— at dimple centers
    color baseColor = color(0.95, 0.27, 0.6);      // match base color in .rib
    float shadowAmount = 1.0 - 0.3 * bestFalloff;
    shadowTint = color(shadowAmount) * baseColor;  // Uniformly darken RGB channels

    // Raised surface = low falloff; dirt goes outside dimples
    float outerRegion = smoothstep(0.55, 0.6, 1.0 - bestFalloff);  // strongest when far from dimple center

    // Compute dirt effect around dimple rims
    // float rimEdge = smoothstep(0.3, 0.6, bestFalloff) * (1.0 - smoothstep(0.6, 0.9, bestFalloff));

    // Procedural noise to vary dirtiness
    float dirtNoise = noise("perlin", pos * 80); // higher freq results in finer dirt detail
    dirtNoise = smoothstep(0.2, 0.6, dirtNoise); // Threshold for blotchiness

    vector dirtCenter = vector(-0.766084, 0.574468, -0.893861);  // front center
    float distToPatch = distance(pos, dirtCenter);

    // Hard threshold mask
    float jitter = noise("perlin", pos * 25);
    float noisyRadius = 0.5 + jitter * 0.15;
    float dirtLocation = 1.0 - smoothstep(noisyRadius - 0.05, noisyRadius + 0.05, distToPatch);

    // float dirtLocation = distToPatch < 0.5 ? 1.0 : 0.0;

    float dirtMask = clamp(outerRegion * dirtNoise * dirtLocation * 3.0, 0.0, 1.0); // Combine shape and noise
    color dirtColor = color(0.122, 0.078, 0.012); // brownish dirt tone

    // blend clean surface with dirt
    shadowTint = mix(shadowTint, dirtColor, dirtMask);
}